<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Agent-based model simulating interpersonal bias in mode choice within a transportation network.">

<title>Zoey Yandell - That’s How I Roll: The impact of bias in transportation mode choice</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Zoey Yandell</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../education.html" rel="" target="">
 <span class="menu-text">Education</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../experience.html" rel="" target="">
 <span class="menu-text">Experience</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html" rel="" target="">
 <span class="menu-text">Projects</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<div class="quarto-about-marquee">
  <div class="about-image-container">
    <img src="transit_network.png" class="about-image " style="width: 100%;">
  </div>
  <div class="about-contents">
    <header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">That’s How I Roll: The impact of bias in transportation mode choice</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Data</div>
    <div class="quarto-category">Urbanism</div>
  </div>
  </div>
<div>
  <div class="description">
    Agent-based model simulating interpersonal bias in mode choice within a transportation network.
  </div>
</div>
<div class="quarto-title-meta">
  </div>
</header> <main class="content" id="quarto-document-content">
<p>In this capstone project, I used agent-based modeling in Python to simulate human patterns of movement within a transportation system, focusing on mode choice between private vehicles and public transit. I added a coefficient of bias to investigate the emergent behavior of the system when transit mode choices were influenced by the proportions of other riders, finding that interpersonal bias in this model can exacerbate exisiting disparities between groups of travelers.</p>
<p>The full report on this project can be read <a href="TravelModelReport.pdf">here</a>. <!-- The following is a simplified version of the code used to generate my results. --></p>
<!-- ## Code -->
<!-- ```{python} -->
<!-- from numpy import * -->
<!-- from numpy.random import choice -->
<!-- from random import randint, choice -->
<!-- ### Initialize -->
<!-- # matrix of connections -->
<!-- Network = array([[1, 1, 1, 0, 0, 0, 0, 0], -->
<!--           [1, 1, 1, 0, 0, 0, 0, 0], -->
<!--           [1, 1, 1, 1, 0, 0, 0, 0], -->
<!--           [0, 0, 1, 1, 1, 1, 0, 0], -->
<!--           [0, 0, 0, 1, 1, 1, 1, 0], -->
<!--           [0, 0, 0, 1, 1, 1, 1, 1], -->
<!--           [0, 0, 0, 0, 1, 1, 1, 1], -->
<!--           [0, 0, 0, 0, 0, 1, 1, 1]]) -->
<!-- # matrix of relative appeal -->
<!-- high = 0.8 -->
<!-- med = 0.5 -->
<!-- low = 0.2 -->
<!-- relApp = array([[0, low, med, 0, 0, 0, 0, 0], -->
<!--           [low, 0, med, 0, 0, 0, 0, 0], -->
<!--           [med, med, 0, high, 0, 0, 0, 0], -->
<!--           [0, 0, high, 0, high, med, 0, 0], -->
<!--           [0, 0, 0, high, 0, med, low, 0], -->
<!--           [0, 0, 0, med, med, 0, low, med], -->
<!--           [0, 0, 0, 0, low, low, 0, low], -->
<!--           [0, 0, 0, 0, 0, med, low, 0]]) #remember matrices are 0-7 -->
<!-- class person: -->
<!--     def __init__(self): -->
<!--         self.location = 0 # later randomize 0-7 -->
<!--         self.affiliation = 0 # later determine -1 or 1 -->
<!--         self.appeal = 0 -->
<!--         self.comfort = 0 # later randomize, sum to 1 -->
<!-- ``` -->
<!-- The following function runs a model with strong bias interactions on the part of both groups. It takes as input a network and relative appeals matrix defined above, a maximum amount of timesteps, a number of agents, an amount of destinations, and a "bar" which defines the borders between the neighborhoods, as seen in the title image and described in the report. -->
<!-- ```{python} -->
<!-- def transitMove(network, relapp, tmax = 10, n = 10000, m = 8, bar = 4): -->
<!--     # empty matrices of travelers -->
<!--     locations = zeros((m,tmax)) -->
<!--     transit_1 = zeros((m ,m, tmax)) -->
<!--     transit_1[:,:,0] = ones((m,m)) -->
<!--     transit_2 = zeros((m, m, tmax)) -->
<!--     transit_2[:,:,0] = ones((m,m)) -->
<!--     cars_1 = zeros((m, m, tmax)) -->
<!--     cars_1[:,:,0] = ones((m,m)) -->
<!--     cars_2 = zeros((m, m, tmax)) -->
<!--     cars_2[:,:,0] = ones((m,m)) -->
<!--     # randomize people -->
<!--     people = [person() for j in range(n)] -->
<!--     for i in people: -->
<!--         i.location = randint(0,m - 1) -->
<!--         locations[i.location,0] +=1 -->
<!--         if (i.location <bar): -->
<!--             i.affiliation = 1 -->
<!--         else: -->
<!--             i.affiliation = 2 -->
<!--         appeal = randint(1,100) -->
<!--         comfort = randint(1,100) -->
<!--         total = appeal + comfort -->
<!--         i.appeal = appeal/total -->
<!--         i.comfort = comfort/total -->
<!--     # run the model -->
<!--     comfortCoeff1 = zeros((m,m,tmax)) -->
<!--     comfortCoeff2 = zeros((m,m,tmax)) -->
<!--     transitTravTotal = zeros((m,m)) -->
<!--     for t in range(tmax-1): -->
<!--         # create matrix of comfort coefficients -->
<!--         transitTravTotal = transitTravTotal + transit_1[:,:,t] + transit_2[:,:,t] # total travelers over all of human history -->
<!--         comfortCoeff1[:,:,t] = sum(transit_1[:,:,0:(t+1)], axis = 2)/transitTravTotal  -->
<!--         comfortCoeff2[:,:,t] = sum(transit_2[:,:,0:(t+1)], axis = 2)/transitTravTotal  -->
<!--         for i in people: -->
<!--             # select destination -->
<!--             row = network[i.location] -->
<!--             indices = where(row == 1) -->
<!--             destination = choice(indices[0]) -->
<!--             if (destination == i.location): -->
<!--                 locations[i.location,t+1] +=1 -->
<!--             else: -->
<!--                 # calculate preference -->
<!--                 if (i.affiliation ==1): -->
<!--                   preference = i.appeal * relapp[i.location,destination]+ i.comfort * comfortCoeff1[i.location, destination, t] -->
<!--               else: -->
<!--                   preference = i.appeal * relapp[i.location,destination]+ i.comfort * comfortCoeff2[i.location, destination, t] -->
<!--                 # choose mode -->
<!--                 choiceVar = randint(0,100)/100 -->
<!--                 if (preference > choiceVar): -->
<!--                     # they choose transit -->
<!--                     if (i.affiliation ==1): -->
<!--                         transit_1[i.location, destination, t+1] += 1 -->
<!--                     else: -->
<!--                         transit_2[i.location, destination, t+1] += 1 -->
<!--                 else: -->
<!--                     # they choose car -->
<!--                     if (i.affiliation ==1): -->
<!--                         cars_1[i.location, destination, t+1] += 1 -->
<!--                     else: -->
<!--                         cars_2[i.location, destination, t+1] += 1 -->
<!--                 # update location -->
<!--                 i.location = destination -->
<!--                 locations[i.location,t+1] +=1 -->
<!--             # end if statement -->
<!--         # end for loop -->
<!--     results = {"transit_1": transit_1, "transit_2": transit_2, "cars_1": cars_1,"cars_2": cars_2, "locations": locations} -->
<!--     return(results) -->
<!-- ``` -->
<!-- The following function graphs some of the outputs of this model in a way that compares transit adoption percentages for the two groups. -->
<!-- ```{python} -->
<!-- import matplotlib as mpl -->
<!-- import matplotlib.pyplot as plt -->
<!-- def plot_pop_compare(transit_1, transit_2, locations, title = False, n = 10000, tmax = 10, bar = 4): -->
<!--     transit_1_totals = sum(sum(transit_1, axis = 1),axis = 0) -->
<!--     transit_2_totals = sum(sum(transit_2, axis = 1),axis = 0) -->
<!--     time = arange(tmax) -->
<!--     transit_1_pop = sum(locations[0:bar,0]) -->
<!--     transit_2_pop = sum(locations[bar:,0]) -->
<!--     transit_1_percent = transit_1_totals/transit_1_pop -->
<!--     transit_2_percent = transit_2_totals/transit_2_pop -->
<!--     if (transit_1_pop + transit_2_pop == n): -->
<!--         fig, ax = plt.subplots() -->
<!--         line1, = ax.plot(transit_1_percent, label='Group 1') -->
<!--         line2, = ax.plot(transit_2_percent, label='Group 2') -->
<!--         ax.legend(handles=[line1, line2]) -->
<!--         ax.set_xlabel("timestep") -->
<!--         ax.set_ylabel("transit users (percent)") -->
<!--         ax.set_ylim(0,0.6) -->
<!--         if title: -->
<!--             fig.savefig(title) -->
<!--         plt.show() -->
<!--     else: -->
<!--         print("Population Sum Error") -->
<!-- ``` -->
<!-- ```{python} -->
<!-- transitResults = transitMove(Network, relApp, tmax = 50, bar = 4) -->
<!-- transit_1 = transitResults['transit_1'] -->
<!-- transit_2 = transitResults['transit_2'] -->
<!-- locations = transitResults['locations'] -->
<!-- plot_pop_compare(transit_1, transit_2, locations, tmax = 50, bar = 4) -->
<!-- ``` -->


</main> 
  </div>
</div>
 <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>